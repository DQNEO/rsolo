#!/bin/bash
#
# rsolo - a bash knife-solo
#
set -e

PROG=$(basename $0)
VERSION="0.0.1"
rsync_verbose=""
why_run=""
vagrant_mode=""
tmp_file="${TMPDIR}rsolovagrantsshconfig.$$"
remote_dir='~/'${PROG}

usage() {
    cat  <<EOF
Usage: $PROG [--version] [--help] <command> [options] [args]

Subcommands are:
    $PROG prepare   [options] [user@]hostname
    $PROG cook      [options] [user@]hostname

'$PROG <command> --help' shows help about a specific subcommand
EOF
}

version() {
    echo "$PROG $VERSION"
}

usage_cmd_prepare() {
    cat  <<EOF
Usage: $PROG prepare [OPTIONS] [ARGS]
EOF
}

usage_cmd_cook() {
    cat  <<EOF
Usage: $PROG cook [OPTIONS] [USER@]HOSTNAME
    -N, --node-name NAME             The Chef node name for your new node
    -i, --identity-file FILE         The ssh identity file
    -F CONFIG_FILE,                  Alternate location for ssh config file
        --ssh-config-file
    -p, --ssh-port PORT              The ssh port
    -W, --why-run                    Enable whyrun mode
    -h, --help                       Show this message


EOF

# TODO
#    -E, --environment ENVIRONMENT    The Chef environment for your node
#        --format FORMAT              Which format to use for output
#    -o RunlistItem,RunlistItem...,,  Replace current run list with specified items
#        --override-runlist
#    -r, --run-list RUN_LIST          Comma separated list of roles/recipes to put to node config (if it does not exist)
#    -V, --verbose                    More verbose output. Use twice for max verbosity
}

if [[ $# -eq 0 ]]; then
    usage
    exit 1
fi

if [[ "$1" = "--debug" ]]; then
    set -x
    IS_DEBUG=1
    rsync_verbose="-v"
    shift
fi

if [[ "$1" = "--help" || "$1" = "-h" ]]; then
    usage
    exit 1
fi

if [[ "$1" = "--version" || "$1" = "-v" ]]; then
    version
    exit
fi

subcmd=$1
shift

ssh_options=""

# http://qiita.com/b4b4r07/items/dcd6be0bb9c9185475bb#2-2
for OPT in "$@"
do
    case "$OPT" in
        '-h'|'--help'|'help' )
            usage_cmd_${subcmd}
            exit 1
            ;;
        '-F')
            if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]]; then
                echo "$PROG: option requires an argument -- $1" 1>&2
                exit 1
            fi
            ssh_options="$ssh_options -F $2"
            shift 2
            ;;
        '-i')
            if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]]; then
                echo "$PROG: option requires an argument -- $1" 1>&2
                exit 1
            fi
            ssh_options="$ssh_options -i $2"
            shift 2
            ;;
        '-p')
            if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]]; then
                echo "$PROG: option requires an argument -- $1" 1>&2
                exit 1
            fi
            ssh_options="$ssh_options -p $2"
            shift 2
            ;;
        '-N')
            if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]]; then
                echo "$PROG: option requires an argument -- $1" 1>&2
                exit 1
            fi
            node_name=$2
            shift 2
            ;;
        '-b'|'--long-b' )
            if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]]; then
                shift
            else
                shift 2
            fi
            ;;
        '-W'|'--why-run' )
            why_run="-W"
            shift 1
            ;;
        '--vagrant' )
            vagrant_mode=1
            shift 1
            ;;
        '--'|'-' )
            shift 1
            param+=( "$@" )
            break
            ;;
        -*)
            echo "$PROG: illegal option -- '$(echo $1 | sed 's/^-*//')'" 1>&2
            exit 1
            ;;
        *)
            if [[ ! -z "$1" ]] && [[ ! "$1" =~ ^-+ ]]; then
                #param=( ${param[@]} "$1" )
                param+=( "$1" )
                shift 1
            fi
            ;;
    esac
done

# show usage when no args
if [[ -z $param && ! "$vagrant_mode" ]]; then
    usage_cmd_${subcmd}
    exit 1
fi

_setup_ssh() {
    if [[ $vagrant_mode ]]; then
        vagrant ssh-config --host=tmphost > $tmp_file
        hostname=tmphost
        ssh_options="-F $tmp_file"
        if [[ ! $node_name ]]; then
            node_name="vagrant"
        fi

        jsonfile=nodes/${node_name}.json
    else
        hostname=${param[0]}
        jsonfile=nodes/${node_name}.json
    fi

    if [[ ! -e $jsonfile ]] ; then
        echo "$jsonfile file not found" >&2
        exit 1
    fi

    ssh_cmd="ssh $ssh_options $hostname"
}

_rm_ssh_tmpconfig() {
    [[ -e $tmp_file ]] && rm $tmp_file
}

cmd_cook() {

    _setup_ssh
    echo "Running Chef on ${hostname}..."

    echo "Uploading the kitchen..."

    sync

    cat $jsonfile | $ssh_cmd "cat > $remote_dir/dna.json"

    environment=$(grep environment $jsonfile | awk -F: '{print $2}' | sed -e 's/[",]//g')

    echo "Generating solo config..."
    # generate solo.rb
    cat <<EOF |  $ssh_cmd "cat > $remote_dir/solo.rb"

# generated by $PROG
base = File.expand_path('..', __FILE__)

nodes_path                File.join(base, 'nodes')
role_path                 File.join(base, 'roles')
data_bag_path             File.join(base, 'data_bags')
encrypted_data_bag_secret File.join(base, 'data_bags/data_bag_key')
environment_path          File.join(base, 'environments')
ssl_verify_mode           :verify_peer

environment               "$environment"

cookbook_path []
cookbook_path << File.join(base, 'site-cookbooks')
cookbook_path << File.join(base, 'cookbooks')

EOF


    cmd_remote="sudo chef-solo $why_run -c $remote_dir/solo.rb -j $remote_dir/dna.json"
    echo "Running Chef: $cmd_remote"

    $ssh_cmd $cmd_remote

    _rm_ssh_tmpconfig
}

cmd_prepare() {
    _setup_ssh

    # About the Omnibus Installer
    # https://docs.getchef.com/install_omnibus.html
    $ssh_cmd "curl -L https://www.getchef.com/chef/install.sh | sudo bash"
    _rm_ssh_tmpconfig
}

sync() {

    if $ssh_cmd "type rsync >/dev/null 2>&1" ; then
        # rsync
        rsync -rL $rsync_verbose --rsh="$ssh_cmd" --delete-after --exclude=revision-deploys --exclude=tmp --exclude=.git --exclude=.hg --exclude=.svn --exclude=.bzr . :$remote_dir
    else
        # scp
        cmd_clean
        scp -r $ssh_options . ${hostname}:${remote_dir}/
    fi

}

_clean() {
    $ssh_cmd "rm -rf $remote_dir"
}

cmd_clean() {
    _setup_ssh
    _clean
}

cmd_${subcmd}


