#!/bin/bash
#
# rsolo - a bash knife-solo
#
set -e

PROG=$(basename $0)
VERSION="0.0.1"
rsync_verbose=""

usage() {
    cat  <<EOF
Usage: $PROG SUBCOMMAND [OPTIONS] [ARGS]
** $PROG subcommands **
$PROG bootstrap [USER@]HOSTNAME [JSON] (options)
$PROG prepare   [USER@]HOSTNAME [JSON] (options)
$PROG cook      [USER@]HOSTNAME [JSON] (options)
$PROG clean     [USER@]HOSTNAME
$PROG init      DIRECTORY
EOF
}

usage_cmd_prepare() {
    cat  <<EOF
Usage: $PROG prepare [OPTIONS] [ARGS]
EOF
}

usage_cmd_cook() {
    cat  <<EOF
Usage: $PROG cook [OPTIONS] [ARGS]
EOF
}

if [[ $# -eq 0 ]]; then
    usage
    exit 1
fi

if [[ "$1" = "--debug" ]]; then
    set -x
    IS_DEBUG=1
    rsync_verbose="-v"
    shift
fi

if [[ "$1" = "--help" || "$1" = "-h" ]]; then
    usage
    exit 1
fi

subcmd=$1
shift

ssh_options=""

# http://qiita.com/b4b4r07/items/dcd6be0bb9c9185475bb#2-2
for OPT in "$@"
do
    case "$OPT" in
        '-h'|'--help'|'help' )
            usage_cmd_${subcmd}
            exit 1
            ;;
        '-F')
            if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]]; then
                echo "$PROG: option requires an argument -- $1" 1>&2
                exit 1
            fi
            ssh_options="$ssh_options -F $2"
            shift 2
            ;;
        -*)
            echo "$PROGNAME: illegal option -- '$(echo $1 | sed 's/^-*//')'" 1>&2
            exit 1
            ;;
        *)
            if [[ ! -z "$1" ]] && [[ ! "$1" =~ ^-+ ]]; then
                #param=( ${param[@]} "$1" )
                param+=( "$1" )
                shift 1
            fi
            ;;
    esac
done

# show usage when no args
#
#if [ -z $param ]; then
#    usage
#    exit 1
#fi

echo ssh_options = $ssh_options
hostname=${param[1]}

echo hostname = $hostname
#jsonfile=$4

remote_dir='~/'${PROG}
ssh_cmd="ssh $ssh_options $hostname"

cook () {


    # generate solo.rb
    cat <<EOF > solo.rb
base = File.expand_path('..', __FILE__)

nodes_path                File.join(base, 'nodes')
role_path                 File.join(base, 'roles')
data_bag_path             File.join(base, 'data_bags')
encrypted_data_bag_secret File.join(base, 'data_bag_key')
environment_path          File.join(base, 'environments')
ssl_verify_mode           :verify_peer

cookbook_path []
cookbook_path << File.join(base, 'site-cookbooks')
cookbook_path << File.join(base, 'cookbooks')

EOF

    cat $jsonfile | $ssh_cmd "cat > $remote_dir/dna.json"

    # cook
    $ssh_cmd "sudo chef-solo -c $remote_dir/solo.rb -j $remote_dir/dna.json -N vagrant-dqneo -o hello"
}

sync() {
    # rsync
    rsync -rL $rsync_verbose --rsh="$ssh_cmd" --delete-after --exclude=revision-deploys --exclude=tmp --exclude=.git --exclude=.hg --exclude=.svn --exclude=.bzr . :$remote_dir
}

clean() {
    $ssh_cmd "sudo rm -rf $remote_dir"
}

echo ssh_cmd $ssh_cmd
exit

$subcommand
